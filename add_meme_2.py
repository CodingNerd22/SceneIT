# -*- coding: utf-8 -*-
"""add_meme_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bll7wWELI30urw_Be8cO3dbL4CPyAQcR
"""

# Step 0: Install required packages
!pip install transformers PyPDF2 scikit-learn --quiet

# Step 1: Imports
import re
import pandas as pd
import PyPDF2
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from transformers import pipeline
import torch

# Step 2: Load emotion classifier
emotion_classifier = pipeline(
    "text-classification",
    model="finiteautomata/bertweet-base-sentiment-analysis",
    device=0 if torch.cuda.is_available() else -1
)

def get_emotion(text):
    result = emotion_classifier(text[:512])[0]
    label = result['label']
    emotion_map = {
        'POS': 'funny',
        'NEG': 'sadness',
        'NEU': 'neutral'
    }
    return emotion_map.get(label, 'neutral'), result['score']

# Step 3: PDF Dialogue Extractor
def extract_dialogues_from_pdf(pdf_path):
    dialogues = []
    current_entry = {}

    with open(pdf_path, 'rb') as file:
        reader = PyPDF2.PdfReader(file)
        for page in reader.pages:
            text = page.extract_text()
            if not text:
                continue
            for line in text.split('\n'):
                line = line.strip()
                if '===== Page' in line or (line.startswith('Page') and '/' in line):
                    continue
                if line.startswith('Dialogue:'):
                    if current_entry and 'Dialogue' in current_entry:
                        dialogues.append(current_entry)
                        current_entry = {}
                    current_entry['Dialogue'] = line.replace('Dialogue:', '').strip()
                elif line.startswith('Emotion:'):
                    match = re.match(r'Emotion:\s*(\w+)\s*\(Score:\s*([\d.]+)\)', line)
                    if match:
                        current_entry['Original_Emotion'] = match.group(1).lower()
                        current_entry['Old_Score'] = float(match.group(2))
                elif line.startswith('---') and 'Dialogue' in current_entry and 'Original_Emotion' in current_entry:
                    dialogues.append(current_entry)
                    current_entry = {}

    if current_entry and 'Dialogue' in current_entry and 'Original_Emotion' in current_entry:
        dialogues.append(current_entry)

    return pd.DataFrame(dialogues)

# Step 4: Dynamic Keyword Extractor using Zero-shot Classification
zero_shot_classifier = pipeline("zero-shot-classification", model="facebook/bart-large-mnli")

# Define high-level topic categories (can expand)
topic_labels = ["money", "love", "anger", "food", "funny", "sadness", "neutral", "romance", "sarcasm"]

def extract_keywords(text):
    result = zero_shot_classifier(text[:512], topic_labels, multi_label=True)
    # Return top 3 topics with score > 0.3
    keywords = [label for label, score in zip(result['labels'], result['scores']) if score > 0.3][:3]
    return keywords

# Step 5: Find Best Matching Meme for a Scene
def get_best_meme_for_scene(scene_text, df, tfidf, tfidf_matrix):
    scene_emotion, _ = get_emotion(scene_text)
    scene_keywords = extract_keywords(scene_text)
    scene_vec = tfidf.transform([scene_text])
    similarity_scores = cosine_similarity(scene_vec, tfidf_matrix).flatten()

    best_meme = None
    best_score = 0

    for i, row in df.iterrows():
        meme_text = row['Dialogue']
        meme_emotion, _ = get_emotion(meme_text)
        if meme_emotion != scene_emotion:
            continue

        meme_keywords = extract_keywords(meme_text)
        keyword_overlap = set(scene_keywords) & set(meme_keywords)
        keyword_score = 1.0 if keyword_overlap else 0.0
        final_score = 0.6 * similarity_scores[i] + 0.4 * keyword_score

        if final_score > best_score:
            best_score = final_score
            best_meme = meme_text

    return best_meme if best_meme else "ðŸ˜¢ No relevant meme found with matching emotion."

# Step 6: Insert Meme After Trigger Word
def insert_meme_after_trigger(scene_text, trigger_word, meme_line):
    pattern = re.escape(trigger_word)
    match = re.search(pattern, scene_text, re.IGNORECASE)
    if not match:
        return scene_text + " [Note: Trigger word not found to insert meme.]"

    insert_index = match.end()
    return scene_text[:insert_index] + " " + meme_line + " " + scene_text[insert_index:]

# Step 7: Run Everything
pdf_path = "/content/drive/MyDrive/Python/meme_data_2.pdf"  # Update if needed

df = extract_dialogues_from_pdf(pdf_path)
df = df.dropna(subset=['Dialogue'])

# Build TF-IDF matrix
tfidf = TfidfVectorizer(stop_words='english', max_features=25000)
tfidf_matrix = tfidf.fit_transform(df['Dialogue'])

# Define scene and trigger
scene_text = "If this deal goes through, bro... itâ€™s gonna be money, money everywhere!"
trigger_word = "money"

# Find meme and insert
best_meme_line = get_best_meme_for_scene(scene_text, df, tfidf, tfidf_matrix)
final_scene = insert_meme_after_trigger(scene_text, trigger_word, f"[Meme: {best_meme_line}]")

# Output
print("ðŸŽ¬ Modified Scene with Meme Inserted:\n")
print(final_scene)